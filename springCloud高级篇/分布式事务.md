### 一、分布式事务理论基础

**事务的acid原则**

* 原子性：事务中的所有操作，要么全部成功，要么全部失败
* 一致性：保证数据库内部完整约束性、声明性约束
* 隔离性：对同一资源操作的事务不能同时发生
* 持久性：对数据库的一切修改将永久保存，不关是否出现故障

**分布式事务：**在分布式系统下，一个业务跨越多个服务或数据源，每个服务都是一个分支事务，要保证所有分支事务最终状态一致，这样的事务就是分布式事务



**CAP定理**：分布式系统有三个指标：

* Consistency（一致性）
* Availability（可用性）
* Partition tolerance（分区容错性）

但是分布式系统无法同时满足这三个指标，只能最多同时满足两个指标。这就是CAP定理

**Consistency（一致性）：**用户访问分布式系统中的任意节点，得到的数据必须一致。（当某一节点数据发生修改时，及时对它的其余分片同步）

**Availability（可用性）：**用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝

**Partition tolerance（分区容错性：**

* **Partition（分区）：**因为网络故障或其他原因导致分布式系统中的部分节点与其他节点市区连接，形成独立分区
* **Tolerance（容错）：**在集群出现分区时，整个系统也要持续对外提供服务

**CAP定理总结：**

* 分布式系统节点通过网络连接，一定会出现分区问题（P）
* 当分区出现时，系统的一致性（C）和可用性（P）就无法同时满足

**ES集群属于CP**

* ES集群出现分区时，故障节点会被剔除集群，数据分片会重新分配到其他节点，保证数据一致。因此是低可用性、高一致性。属于CP



**BASE理论：BASE理论是对CAP的一种解决思路，包含三个思想**

* **Basically Available（基本可用）：**分布式系统在出现故障时，允许损失部分可用性，即保证核心可用
* **Soft State（软状态）：**在一定时间内，允许出现中间状态，比如临时的不一致状态
* **Eventually Consistent（最终一致性）：**虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致性

分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴CAP定理和BASE理论：

* **AP模式：**各子事务分别执行和提交，允许出现结果不一致，然后采取弥补措施恢复数据即可，实现最终一致
* **CP模式：**各个子事务执行后互相等待，同时提交，同时回滚，达成**强一致**。但事务等待过程中，处于弱可用状态

解决分布式事务，各个子系统之间必须能**感知到彼此**的事务状态，才能保证状态一致性，因此需要一个**事务协调者**来协调每一个事务的参与者（子系统事务）

这里的子系统事务，称为**分支事务**；有关联的各个分支事务在一起称为**全局事务**



### 二、初始Seata

Seata事务管理中的三个重要角色：

* **TC（Transaction Coordinator）- 事务协调者（协调TM和RM）：**维护全局事务和分支事务的状态，协调全局事务提交或回滚
* **TM（Transaction Manager）- 事务管理器：**定义全局事务的范围、开始全局事务、提交或回滚全局事务
* **RM（Resource Manager）- 资源管理器：**管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并以驱动分支事务提交或回滚

Seata提供的四种不同分布式事务解决方案：

* **XA模式：**强一致性分阶段事务模式，牺牲了一定可用性，无业务入侵

  优点：

  * 事务的**强一致性**，满足ACID原则
  * **常用数据库都支持，实现简单**，并且没有代码入侵

  缺点：

  * 因为一阶段需要锁定数据库资源，等待二阶段结束释放，**性能较差**

* **TCC模式：**最终一致的分阶段事务模式，有业务入侵

  **原理：**TCC模式与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法：

  * Try：资源的检测和预留
  * Confirm：完成资源操作业；要求Try成功Confirm一定成功
  * Cancel：预留资源释放，可以理解为Try的反向操作

  eg：一个扣减用户余额的业务。假设账户A原来余额是100，需要从余额中扣减30

  阶段一（Try）：检查余额是否充足，如果充足则冻结金额增加30，可用余额减少30

  阶段二（Confirm）：如果要提交（Confirm），则冻结金额扣30

  阶段三（Cancel）：如果要回滚（Cancel），则冻结余额扣减30，可用余额增加30

  **如果再出现上述两个事务的情况，就会事务一冻结30，剩70，事务二冻结30，剩40。每个事务互相独立，不影响。于是就不用加锁，大大提升了性能**

  对比：AT是记录初始值，TCC是记录变化的部分值

  优点：

  * 一阶段完成直接提交事务，释放数据库资源，性能好
  * 相比于AT模型，无需生成快照，无需使用全局锁，性能最强
  * 不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库

  缺点：

  * 有代码入侵，需要人为编写try、confirm、cancel接口
  * 软状态，事务是最终一致
  * 需要考虑Confirm和Cancel的失败情况，做好幂等处理

* **AT模式（先提交，失败后根据分支事务状态，利用快照恢复数据。弥补了XA模式中资源锁定周期过长的缺陷）：**最终一致的分阶段事务模式，无业务入侵，也是Seata的默认模式

  一阶段：

  * 注册分支事务
  * **记录undo-log（数据快照）**
  * 执行业务SQL并提交
  * 报告事务状态

  成功时的二阶段：

  * 删除undo-log

  失败时的二阶段：

  * 根据undo-log恢复数据到更新前

  优点：

  * 一阶段完成直接提交事务，释放数据资源，性能更好
  * 利用全局锁实现读写隔离
  * 没有代码入侵，框架自动完成回滚和提交

  缺点：

  * 两阶段之间属于软状态，属于最终一致
  * 框架的快照功能会影响性能，但比XA模式要好很多

  **空回滚：**当某分支事务的try阶段发生堵塞时，可能会导致全局事务超时而触发二阶段的cancel操作（相当于未执行try却执行了cancel）。在未执行try操作时，先执行了cancel操作，这时cancel不能做回滚，就是空回滚。

  **业务悬挂：**在发生**空回滚后**，原来堵塞的业务又正常了，相当于回滚已经这执行了又继续执行try。对于已经空回滚的业务，如果以后继续执行try，就永远不可能confirm或cancel，这就是业务悬挂。

  **业务悬挂解决办法：**在执行cancel前判断是否执行了try，在执行try之前，判断是否执行了cancel。在数据库中加一张表用来记录当前事务的状态属于try或者cancel。

* **SAGA模式：**长事务模式，有业务入侵



**AT模式的脏读问题：**

当事务一执行第一阶段时：1. 获取DB锁，保存快照（money = 100）  2. 执行业务SQL（set money = 90）3. 提交事务，释放锁  

当事务一还没进入第二阶段时，事务二拿到锁，进行和一一样的步骤，然后对数据进行修改（set money = 80），形成的快照（money = 90）

此时有一个分支业务失败，事务一根据快照一进行回滚，money = 100.(**导致事务二的修改就不生效**)



**全局锁：**由TC记录当前正在操作某行数据的事务，该事务持有全局锁，具备执行权

执行步骤和上述一样，但**在执行业务SQL后，提交事务前，需要获取全局锁。**事务一获取全局锁之后，提交事务，释放DB锁。再次**当事务二进来**，获取DB锁，在执行业务SQL后，提交事务前，需要获取全局锁时。拿不到全局锁无法提交事务。（**注：此时DB锁在事务二中，事务二在等待获取全局锁；全局锁在事务一中，事务一在等待获取DB锁（事务失败时需要获取DB锁，根据快照恢复数据）。但是并不会形成死锁，因为获取全局锁的最大等待时间比DB锁，事务二会直接失败**）

性能高于XA模式的原因在于锁的细腻度不同，无法获取DB锁任何事物都无法访问数据库。而无法获取全局锁，只有seata管理的事务无法访问。

**问题：当事务不是由seata管理的事务时，就会导致事务二更新失败（和上诉脏读问题一样）**：

**解决方案：判断事务中间，这条数据是否被修改过**

**在事务一执行时，会记录两张快照，一张是修改数据前的，一张是修改数据后的。修改数据的快照用于恢复数据。修改数据后的快照就是用于与数据库中数据做对比，判断事务中间，这条数据是否被修改过**



