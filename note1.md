### 一、为什么重写equals()就一定要重写hashCode()方法

如果只重写equals()方法而不重写hashCode()方法，就会出现两个对象值相等而hashCode却不相等，这意味着一个完全相同的对象存放在了hash表的两个不同位置，当需要获取对象时，可能会出现一些不可预料的错误

``` java
// 在比较两个对象是否相等时，会先调用hashCode()方法比较hashCode值是否相等
// 然后再调用equals()方法，大大提高了进行比较的效率
```



### 二、过滤器（Filter）和拦截器(Interceptor)有什么区别

##### 1. 运行的顺序不同(Filter->Servlet->Interceptor->Controller)

(1) 过滤器是在Servlet容器接受到请求后，但是在Servlet被调用前运行的

(2) 拦截器是在Servlet被调用后，但是在响应被发送到客服端之前运行的

##### 2. 配置方式不同

(1) 过滤器在web.xml里配置

(2) 拦截器在Spring配置文件中配置或者使用注解的方式进行配置

(3) Filter依赖于Servlet容器，而Interceptor不依赖一Servlet容器

(4)Filter在过滤器中只能对request和response进行操作；而Interceptor可以对request、response、handler、modeAndView、exception进行操作（多了对于Spring MVC生态的组件的一个操作能力）



### 三、ArrayList的自动扩容机制

1. ArrayList是一个数组结构的存储容器，默认情况下数组的长度是10个（也可以在构建ArrayList对象的时候指定初始长度）。当ArrayList中添加的数据达到10个的时候，ArrayList触发自动扩容
2. 自动扩容：创建一个新的数组，这个新数组的长度是原来数组长度的1.5倍。然后使用Arrays.copyOf()这个方法把老数组中的数据拷贝到新数组中



### 四、Cookie和Session的区别

1. **cookie：客户端浏览器用来保存服务端数据的一种机制**，当我们通过浏览器进行网页访问的时候，服务器可以把一些状态数据以key-value的形式写入到cookie里，存储到客户端浏览器。客户下一次访问访问服务端的时候，我们可以携带这一些状态数据发送到服务器端。服务器端可以cookie里面的内容识别使用者

2. **session：表示一个会话，存储当前会话产生的一些状态数据，它属于服务器端的一个容器对象**。默认情况下Servlet容器会针对每一个浏览器请求分配一个session对象

3. **http协议是一个无状态协议**，服务器端并不知道客户端发送过来的多次请求是属于同一个用户，session是用来弥补http协议无状态的一个不足

4. **利用cookie机制和session机制我们可以去实现一个有状态的http协议**

5. 客户端第一次访问服务器端的时候，服务器端会创建一个会话，并且生成一个唯一的sessionId，来标注这个会话，然后服务器端把这个sessioId写入到客户端浏览器的cookie里，实现客户端状态的保存。在后续的请求里，每次都会携带这个sessionId，服务器端就可以识别这个会话的状态

   ##### 总结：cookie是客户端的存储机制，session是服务器端的存储机制



### 五、如何干预线程的执行顺序

**使用Thread类的join()方法**

join()方法可以使当前线程等待另一个线程执行完毕后在继续执行

``` java
// 在线程一中调用线程二的join()方法，让线程一等待线程二执行结束后，
// 再继续执行

Thread t1 = new Thread(()->{
    // 线程一的代码
    // ...
    t2.strat();
    t2.join();
    // 线程一的代码
    // ...
});
Thread t2 = new Thread(()->{
    // 线程二的代码
    // ...
});
t1.strat();
```



### 六、volatile关键字的作用以及实现原理

1. **保证多线程环境下共享变量的可见性**
2. **通过增加内存屏障防止多个指令之间的重排序**

**可见性**：当一个线程对一个变量修改，其他线程可以立即看到修改之后的值

**可见性问题本质**：

1. **CPU层面的高速缓存**，CPU中设计了三级缓存去解决cpu运算效率和内存IO效率的问题，但是带来了**缓存一致性**的问题。在多线程并行执行下缓存一致性问题就会导致可见性问题。对于volatile关键字修饰的一个变量，JVM虚拟机会自动的增加一个#lock汇编指令，二这个指令会根据不同的CPU型号自动去增加总线锁和或者缓存锁。

   **总线锁**：它锁定的是CPU前端总线，从而在同一个时刻只能有一个线程和内存通信，这样就**避免了多线程并发造成的可见性问题**

   **缓存锁**：缓存锁是对总线锁的一个优化，因总线锁导致了CPU的使用效率大幅度下降，所以缓存锁只针对于CPU三级缓存中的目标数据去加锁

2. **指令重排序**：指令在编写时的顺序和执行时的顺序是不一致的，从而在多线程环境下导致可见性问题。指令重排序本质上是一种性能优化手段。对于共享变量增加了volatile关键字，那么在编译器层面就不会去触发编译器优化，同时在JVM里面，它会插入内存屏障指令去避免重排序问题。

除了volatile以外，从JDK5开始，JMM使用了一种Happens-Before的模型去描述多线程之间的可见性的一个关系。如果两个关系之间具备Happens-Before,那么意味着这两个操作具备可见性的一个关系，不需要在额外考虑增加volatile关键字来提供可见性的一个保障。



### 七、对序列化和反序列化的理解

之所以需要序列化，是为了解决网络通信之间的一个对象传输问题。（一个JVM进程中的对象跨网络传输到另一个JVM进程里面进行恢复）

1. 序列化就是把内存中的对象转化为字节流，以便用来实现存储和传输
2. 反序列化就是根据文件或者网络上获取到的一个字节流，根据字节流保存的对象描述信息和状态，重新构建一个新的对象
3. 序列化的前提是为了保证通信双方对于对象的一个可识别性。所以很多时候，我们会把对象转化为通用的解析格式，比如json、xml等。然后再把它们转化为数据流，进行网络传输，从而实现一个跨平台或者跨语言的一个可识别性。



### 八、new Strng("abc")到底创建了几个对象？

1. 当字符串常量"abc"不存在时，则会创建两个对象。分别是"abc"这个字符串常量，以及”new String“这个实例对象
2. 当字符串常量"abc"不存在时，则只会创建一个对象，就是String这个对象



### 九、SpringBoot如何解决跨域问题

跨域：指的是浏览器执行网页中的Java/script代码时，由于浏览器同源策略的限制，只能访问同源的资源，而不能访问其他源的资源。

比如

``` java
// https://www.aaa.com --> https://www.aaa.com(同源访问)
// https://www.aaa.com --> https://www.bbb.com(跨域访问)
```

在不破坏同源策略的情况下，能够安全地实现数据共享和交互

常见的解决跨域问题的方法有两种：1是jsonp、2是CORS

其中CORS是一种在服务器后端解决跨域的方案。

**CORS工作原理**：如果一个网站需要跨域访问一个网站的资源，浏览器首先会发送一个OPTIONS的请求，根据服务器端返回的Access-Control-Allow-Origin头信息，来决定是否允许跨域访问。

所以我们只需要在服务器端配置Access-Control-Allow-Origin设置允许哪些域名支持跨域请求，就OK了

在SpringBoot中提供了两种配置

``` java
// 1.通过@CrossOrigin注解
@CrossOrigin(origins="http://localhost:8080")

// 2.使用WebMvcConfigurer接口来重写addCorsMappings方法来配置
// 允许跨域的请求源
@Configuration
public class CorsConfig implements WebMvcConfigurer{
    
    @Override
    public void addCorsMappings(CorsRegistry registry){
        regisry.addMappings("/**")
               .allowedOrigins("http:localhost:8080")
               .allowedOrigins("*");
    }
}

```



### 十、线程池如何实现线程复用

线程池采用了一个生产者消费者的模式去实现线程的一个复用。

生产者消费者模型是通过一个中间容器来解耦生产者和消费者的任务处理的过程。生产者不断生产任务保存在容器里面，消费者不断从容器里面消费任务。在线程池里面因为需要保证工作线程的重复使用，这些线程有**任务时执行，没任务时等待，并且释放CPU的资源**。所以他**使用了阻塞队列来实现**。当阻塞队列里没有任何任务的时候，这些工作线程就会阻塞等待，直到有新的任务进来时，这些工作线程被再次唤醒。从而达到线程的复用。