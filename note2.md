### 一. 数据量达到多少要开始分表

结合业务场景和系统架构考虑

1. **单表的数据量**：如果单表的数据量很大，例如超过百万级别，就需要分表
2. **数据库性能**：当单个数据库的性能无法满足业务需求时，需要考虑分库
3. **数据的访问频率**：如果某些表的数据访问评率非常高，单个数据库节点无法满足高并发需求，就需要把这些表分到不同的数据库节点上，去提高整个数据库的IO性能
4. **业务拆分**：当系统业务越来越复杂，不同业务之间的数据耦合度越来越低，就可以考虑对系统进行拆分，以便管理和扩展

``` java
// 单独讨论数据量决定分库分表是不严谨的，决定分库分表的因素很多，比如
// 1.查询性能下降或业务解耦
// 2.数据行的大小（列数）即宽表
// 3.索引大小会决定B+树的层高，层高又间接决定不同数据量级的一个查询性能
// 4.硬件性能配置（带宽，内存，磁盘）
// 5.表结构设计不合理
```



### 二、HashMap什么时候扩容，怎么扩容？

1. 当集合容量达到某个阈值时，进行扩容，HashMap扩容为原来大小的**两倍**（临界值=负载因子*容量大小， **负载因子默认为0.75**）
2. 在集合初始化时，**最好指定容量大小**避免频繁扩容影响性能。
3. 扩容因子为0.75的原因：扩容因子表示Hash表的填充程度，扩容因子越大，整体空间利用率越高，但是Hash冲突的概率也会增加。扩容因子的值是冲突的概率和空间利用率之间的一个平衡。

4. **HashMap采用链式寻址的方式来解决Hash冲突，为了避免链表过长导致时间复杂度增加，当链表长度>8时，就会转换为红黑树提高检索效率。当扩容因子为0.75时，链表长度达到8的可能性几乎为0，比较好的平衡了时间成本和空间成本**



### 三、解决Hash冲突的方法

1. 再hash法：当某个hash函数产生了冲突，就用另一个hash进行计算
2. 开放寻址法：就是直接从冲突的位置寻找下一个空的数组下标
3. 建立公共溢出区：把存在冲突的key统一放在一个公共溢出区里



### 四、HashMap中的hash方法为什么要无符号右移十六位并且进行异或？

**主要是为了要hash值的散列度更高，尽可能减少hash冲突，从而提升数据的查找性能**

原理：hash表的位置i=hash值%(n-1)，一般情况下n的值一般是小于2^16，也就意味着i的值始终是使用hash值的低十六位与(n-1)进行取模运算，这样就会造成key的散列度不是很高，导致大量的key集中存储在一个固定的几个数组位置上，显然影响数据的查找性能。为了提升key的散列度：**将hashCode右移16位，相当于把高位和低位的特征进行了一个组合**，这样得到的i的散列度一定会更高。



### 五、HashMap和HashTable的区别

1. HashTable是**线程安全**的，HashMap不是
2. HashMap性能比HashTable好(HashTable使用了全局同步锁保证线程安全性，对性能较大)
3. HashTable使用数组+链表实现，HashMap使用**数组+链表+红黑树**
4. HashMap初始容量是16，HashTable初始容量是**11**
5. **HashMap可以使用null作为key**(HashMap会把null转化为一个0进行存储)，而HashTable不允许
6. **散列算法不同**，HashTable直接使用hashCode对数组长度取模，而HashMap对hashCode作了二次散列从而避免key的分布不均匀影响到性能

